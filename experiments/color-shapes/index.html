<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Color Shapes</title>
	<script src="js/d3/d3.min.js"></script>
	<script src="js/util.js"></script>
	<script src="js/Vec2.js"></script>
	<script src="js/Color.js"></script>

	<style>
		canvas {
			/*border: 1px solid #333;*/
			padding: 0px;
			padding: 5px;
			margin: 5px;
		}
	</style>
</head>
<body>
	
	<!-- <canvas id="canvas"></canvas> -->
	<div id="canvases"></div>


	<script>

		

		var hl = hexLines(30);
		var width = 150;
		var height = 220;

		var n = 300; //24;
		var canvasesD3 = d3.select("#canvases").selectAll(".canvases").data(d3.range(n))
			.enter().append("canvas")
				.attr("class", "canvases")
				.attr("width", width)
				.attr("height", height);

		var contexts = [];
		var canvases = [];
		canvasesD3.each(function(d,i){
			canvases[i] = this;
			contexts[i] = this.getContext("2d");
		});


		var i = d3.interpolate({colors: ["#ff0000"]}, {colors: ["#00ffff"]});

		var text = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
		// var clist = buildCustomArray(n, function(){ return Color().hex(); });
		var clist = buildCustomArray(n, function(b){ 
			var c = i(b/n).colors.toString();
			c = c.substring(4,c.length-1);
			c = c.split(",");
			c = Color(+c[0], +c[1], +c[2]).hex();
			// console.log(c);
			
			return c;
		})
		colorlist = ["#ff6600", "#0099ff", "#ff0099", "#99ff00", "#0019ff", "#00ffe6"];
		colorlist = colorlist.concat(clist);

		// var loc = new Vec2(100,100);

		var center = new Vec2(width/2, height/2);
		
		window.addEventListener("keydown", function(e){
			if (e.keyCode === 37) {
				// left arrow
				colorlist = buildCustomArray(n, function(){ return Color().hex(); });
				for (var i=1; i<n; i++) {
					color = colorlist[i];

					d3.select(canvases[i]).style("border", "3px solid " + color);

					resetCanvasMatrix(contexts[i]);

					contexts[i].clearRect(0,0,width,height);

					var c = findCentroid(hl, color, Vec2.zero());
					var centroid = new Vec2(-c.centroid.x, -c.centroid.y);
					centroid = Vec2.add(center.clone(), centroid.clone());

					hexTextLoc = new Vec2(width/2, 20);
					contexts[i].fillStyle = color;
					contexts[i].font = "16px Helvetica";
					contexts[i].textBaseline = "middle";
					contexts[i].textAlign = "center";
					contexts[i].fillText(color, hexTextLoc.x, hexTextLoc.y);

		  		drawDynamicPathHex(contexts[i], hl, color, centroid, 3, 4);
				}
				
			}
		})

		drawHexLegend(contexts[0], hexLines(55), center.clone());
		for (var i=1; i<n; i++) {
			color = colorlist[i];

			d3.select(canvases[i]).style("border", "3px solid " + color);

			contexts[i].clearRect(0,0,width,height);

			var c = findCentroid(hl, color, Vec2.zero());
			var centroid = new Vec2(-c.centroid.x, -c.centroid.y);
			centroid = Vec2.add(center.clone(), centroid.clone());

			hexTextLoc = new Vec2(width/2, 20);
			contexts[i].fillStyle = color;
			contexts[i].font = "16px Helvetica";
			contexts[i].textBaseline = "middle";
			contexts[i].textAlign = "center";
			contexts[i].fillText(color, hexTextLoc.x, hexTextLoc.y);

  		drawDynamicPathHex(contexts[i], hl, color, centroid, 3, 4);
		}
		
		function drawHexLegend(ctx, hl, location) {
			var lines = d3.range(16);
			ctx.translate(location.x, location.y);
			ctx.strokeStyle = "rgba(0,0,0,0.3)";
			ctx.fillStyle = "rgba(0,0,0,0.4)";
			for (var i=0; i<lines.length; i++) {
				ctx.beginPath();
				var l = hl(i);
				var b = l.begin;
				var e = l.end;
				// console.log(l.color);
				// ctx.strokeStyle = l.color;
				var normLine = b.clone().add(Vec2.normWithAngle(e.clone().angle() - Math.PI/2).mag(11));
				var negNormLine = normLine.clone().scale(-1);
				
				ctx.lineTo(negNormLine.x, negNormLine.y);
				ctx.lineTo(e.x, e.y);
				ctx.lineTo(normLine.x, normLine.y);
				ctx.lineTo(0,0);
				// ctx.moveTo(b.x, b.y);
				// ctx.lineTo(e.x, e.y);

				var tvec = e.clone();
				var m = tvec.mag();
				tvec = tvec.mag(m*1.2);

				ctx.textBaseline = "middle"; 
				ctx.textAlign = "center"; 
				ctx.fillText(text[i], tvec.x, tvec.y);

				// ctx.stroke();
				ctx.fill();
				ctx.closePath();
			}
			ctx.beginPath();
			ctx.fillStyle = "black";
			ctx.arc(0,0,5,0,2*Math.PI);
			ctx.fill();
			ctx.closePath();
		}

		function findCentroid(lines, hexString, initialPoint) {
			var string = hexString.substring(1);
			var current = initialPoint.clone();

			var points = [];
			points.push({ x: current.x, y: current.y });

			for (var i=0; i<string.length; i++) {
				var digit = string.charAt(i);
				var line = lines(digit);

				current = current.add(line.end.clone()).clone();
				points.push({ x: current.x, y: current.y });
			}

			var xbar = sum(points.map(function(a){ return a.x; })) / points.length;
			var ybar = sum(points.map(function(a){ return a.y; })) / points.length;
			var centroid = { x: xbar, y: ybar };
			return { points: points, centroid: centroid };
		}

		function drawDynamicPathHex(ctx, lines, hexString, initialPoint, linkThickness, startRadius) {
			var absPoints = [];
			var current = initialPoint.clone();

			var color = hexString.toUpperCase();
			var string = hexString.substring(1);

			absPoints.push({ x: current.x, y: current.y });

			ctx.translate(initialPoint.x, initialPoint.y);

			var radius = startRadius;

			for (var i=0; i<string.length; i++) {
				ctx.beginPath();

				var digit = string[i];
				var line = lines(digit);

				// ctx.strokeStyle = "rgba(0,0,0,0.2)";//Color(color).a(0.2).toString();
				
				ctx.fillStyle = color;
				ctx.strokeStyle = "black";
				ctx.lineWidth = 3;
				ctx.arc(0, 0, radius, 0, 2*Math.PI);
				ctx.fill();
				ctx.lineWidth = 1;
				ctx.closePath();
				ctx.beginPath();

				// ctx.strokeStyle = Color(color).a(0.7).toString();
				ctx.strokeStyle = "rgba(0,0,0,0.4)";

				ctx.textBaseline = "middle"; 
				ctx.textAlign = "center"; 

				ctx.moveTo(0,0);

				var normLine = line.begin.clone().add(Vec2.normWithAngle(line.end.clone().angle() - Math.PI/2).mag(linkThickness));
				var negNormLine = normLine.clone().scale(-1);
				
				ctx.lineTo(negNormLine.x, negNormLine.y);
				ctx.lineTo(line.end.x, line.end.y);
				ctx.lineTo(normLine.x, normLine.y);
				ctx.lineTo(0,0);
				// ctx.stroke();
				ctx.fill();
				ctx.closePath();
				ctx.beginPath();

				var tvec = line.end.clone();
				var m = tvec.mag();
				tvec = tvec.mag(m * 0.5);
				var nvec = tvec.add(Vec2.normWithAngle(tvec.angle() + Math.PI/2).mag(15));
				// ctx.fillText(digit, nvec.x, nvec.y);

				ctx.stroke();
				ctx.fill();
				ctx.closePath();
				ctx.beginPath();
				ctx.fillStyle = "white";
				// ctx.fillText(digit, 0, 0);

				ctx.translate(line.end.x, line.end.y);

				current = current.add(line.end.clone());

				absPoints.push({ x: current.x, y: current.y });

				ctx.stroke();
				ctx.fill();
				ctx.closePath();

			}

			ctx.beginPath();
			ctx.strokeStyle = "black";
			ctx.lineWidth = 3;
			// ctx.arc(0,0,radius,0,2*Math.PI);
			ctx.stroke();
			ctx.lineWidth = 1;
			ctx.fill();
			ctx.closePath();
			

			var xExtent = d3.extent(absPoints.map(function(m){ return m.x; }));
			var yExtent = d3.extent(absPoints.map(function(m){ return m.y; }));
			var xCenter = sum(absPoints.map(function(a){ return m.x })) / absPoints.length;
			var yCenter = sum(absPoints.map(function(a){ return m.y })) / absPoints.length;
			var centroid = { x: xCenter, y: yCenter };

			return [xExtent, yExtent, centroid];
		}

		

		function hexLines(scale) {
			var s = undefined ? 1 : scale;
			var n = 16;
			var lines = [];
			var begin = Vec2.zero();
			var angle = 2*Math.PI / n;
			var angleOffset = -Math.PI/2; // + (Math.PI/32);

			for (var i=0; i<n; i++) {
				var end = Vec2.normWithAngle(angle * i + angleOffset).mag(s);
				lines[i] = { begin: begin, end: end };
			}

			return function(i) {
				if (i >= 0 && i < n) i = i;
				else if (i === "a" || i === "A") i = 10;
				else if (i === "b" || i === "B") i = 11;
				else if (i === "c" || i === "C") i = 12;
				else if (i === "d" || i === "D") i = 13;
				else if (i === "e" || i === "E") i = 14;
				else if (i === "f" || i === "F") i = 15;
				else return null;

				return lines[i];
			};
		}


	</script>
</body>
</html>